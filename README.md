# java/Uebung10

## Lambda Expression

- `(parameters) -> expression`或`(parameters) ->{ statements; }`
- Lambda 允许把method作为一个method的parameter（函数作为参数传递进方法中）。
    
    ```java
    // 1. 不需要参数,返回值为 5
    () -> 5
    
    // 2. 接收一个参数(数字类型),返回其2倍的值
    x -> 2 * x
    // int mul(int x){ return 2*x}
    
    // 3. 接受2个参数(数字),并返回他们的差值
    (x, y) -> x – y
    
    // 4. 接收2个int型整数,返回他们的和
    (int x, int y) -> x + y
    
    // 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void)
    (String s) -> System.out.print(s)
    ```
    
- `level.getActors().forEach(actor->actor.act());`
用forEach方法替换循环来遍历所有角色并调用它们的act方法。

任务2：用流`Strömen`在`Field`类的`Konstruktor`中，用`IntStreams`替换生成游戏对象的两个嵌套循环。替代计数循环的一种适当方法是使用`iterate`和`forEach`的组合。

```java
for (int y = 0; y < field.length; y += 2) {
            for (int x = 0; x < field[y].length(); x += 2) {
                gameObjects.add(new GameObject(x / 2, y / 2, 0, NEIGHBORHOOD_TO_FILENAME[getNeighborhood(x, y)]
                        .replace("path", getCell(x, y) == 'W' ? "water" : "path")));
            }
        }
    
```

```java
Field(final String[] field)
    {
        this.field = field;

        IntStream.iterate(0, y -> y < field.length, y -> y + 2)
                .forEach(y -> IntStream.iterate(0, x -> x < field[y].length(), x -> x + 2)
                .forEach(x -> gameObjects.add(new GameObject(x / 2, y / 2, 0, NEIGHBORHOOD_TO_FILENAME[getNeighborhood(x, y)]
                .replace("path", getCell(x, y) == 'W' ? "water" : "path")))));
    }
```

任务3：在流中计算
以第5次练习的解决方案中`Field`类中的`getNeighborhood`方法为例，其中通过循环计算单元格的邻域特征。获取`neighbors`数组，但是用一个表达式替换该方法的其余部分，该表达式使用`IntStream`来计算相同的结果。在此，您还可以运用位运算的知识。`IntStream`中适合的方法包括`range`（或`iterate`），`filter`，`map`和`reduce`（或`sum`）。

- `reduce`方法用于执行类似于累加的操作，上一次调用处理函数的结果会作为入参下一次调用的入参。

任务4：In Strömen sammeln
在Level类中，将文本文件读入字符串列表中。`BufferedReader`类还提供了一个`lines`方法，该方法返回`Stream<String>`。利用该方法的`collect`方法生成列表。

- `lines`

```java
import java.io.IOException;
import java.util.stream.Stream;

public class Main
{
	public static void main(String[] args)
	{
		try
		{
			String str = "A \n B \n C \n D";

			Stream<String> lines = str.lines();

			lines.forEach(System.out::println);
		}
		catch (IOException e)
		{
			e.printStackTrace();
		}
	}
}
A
B
C
D
```

- `collect` : 将指定ELEMENT存放到结果CONTAINER
    - `lines = stream.lines().collect(Collectors.*toList*());`
        - container → `lines`
        
        ```java
        String line;
        while ((line = stream.readLine()) != null) {
                            lines.add(line);
                   }
        
        lines = stream.lines().collect(Collectors.toList());
        ```
        
- 任务5：
    - 用基于Java流的语句替换PI1Game类的主方法中的循环
    
    Java Streams并没有真正提供while循环的直接替代方法，因为它们期望数据持续流经流。因此，必须确保生成这些数据，即使它们实际上并不需要。在下面的实现中，选择了actor，它会由generate反复地传递到流中，因为它至少在"循环"中被使用。
    
    - `Stream.*generate*`
        - **Stream generate(Supplier<T> s)** returns an infinite sequential unordered stream where each element is generated by the provided Supplier. This is suitable for generating constant streams, streams of random elements, etc.
        - `takeWhile`确保在条件变为false时停止处理。forEach像通常一样执行循环体内容。
    
    ```java
    
    Stream.generate(() -> level.getActors())
          .takeWhile(actors -> actors.get(0).isVisible())
          .forEach(actors -> actors.forEach(actor -> actor.act()));
    ```
    
    替代方案
    
    ```java
    
    Stream.iterate(level.getActors(), actors -> actors.get(0).isVisible(), actors -> actors)
          .forEach(actors -> actors.forEach(actor -> actor.act()));
    
    ```
    
     指定一个常量seed，生成从seed到常量f（由UnaryOperator返回的值得到）的流。
